{
  "articles": [
    {
      "path": "about.html",
      "title": "About this site",
      "description": "Some additional details about the website",
      "author": [],
      "contents": "\n\n\n\n",
      "last_modified": "2021-06-07T17:33:44+00:00"
    },
    {
      "path": "index.html",
      "title": "colspec",
      "description": "Column specification\n",
      "author": [],
      "contents": "\nLoad and prep the various packages we use.\n\n\nlibrary(tidyverse)\n\n\n#> ── Attaching packages ───────────────────────────── tidyverse 1.3.1 ──\n#> ✔ ggplot2 3.3.3     ✔ purrr   0.3.4\n#> ✔ tibble  3.1.2     ✔ dplyr   1.0.6\n#> ✔ tidyr   1.1.3     ✔ stringr 1.4.0\n#> ✔ readr   1.4.0     ✔ forcats 0.5.1\n#> ── Conflicts ──────────────────────────────── tidyverse_conflicts() ──\n#> ✖ dplyr::filter() masks stats::filter()\n#> ✖ dplyr::lag()    masks stats::lag()\n\nlibrary(readxl)\nlibrary(googledrive)\nlibrary(googlesheets4)\n\n\n#> \n#> Attaching package: 'googlesheets4'\n#> The following objects are masked from 'package:googledrive':\n#> \n#>     request_generate, request_make\n\ndrive_deauth()\ngs4_deauth()\n\n\n\nThe deaths spreadsheet\nWe use this deaths spreadsheet as a running example. Yes, the dates are formatted in the awful American way, %m/%d/%Y, and there are irritating comments before and after the data.\n\n\n\n\nWe’ll need this as a csv as well.\n\n\ndrive_download(as_id(deaths_url), type = \"csv\", overwrite = TRUE)\n\n\n#> File downloaded:\n#>   * deaths\n#> Saved locally as:\n#>   * deaths.csv\n\nreadr\nreadr offers the richest DSL for column specification (compared to: googlesheets4, readxl).\nhttps://readr.tidyverse.org/reference/index.html#section-column-specification\n\n\ndeaths_csv <- read_csv(\n  \"deaths.csv\",\n  skip = 4, n_max = 10,\n  col_types = cols(\n    Name = col_character(),\n    Profession = col_guess(),\n    Age = col_integer(),\n    `Has kids` = col_logical(),\n    `Date of birth` = col_date(\"%m/%d/%Y\"),\n    `Date of death` = col_date(\"%m/%d/%Y\")\n  )\n)\ndeaths_csv\n\n\n#> # A tibble: 10 x 6\n#>    Name    Profession   Age `Has kids` `Date of birth` `Date of death`\n#>    <chr>   <chr>      <int> <lgl>      <date>          <date>         \n#>  1 David … musician      69 TRUE       1947-01-08      2016-01-10     \n#>  2 Carrie… actor         60 TRUE       1956-10-21      2016-12-27     \n#>  3 Chuck … musician      90 TRUE       1926-10-18      2017-03-18     \n#>  4 Bill P… actor         61 TRUE       1955-05-17      2017-02-25     \n#>  5 Prince  musician      57 TRUE       1958-06-07      2016-04-21     \n#>  6 Alan R… actor         69 FALSE      1946-02-21      2016-01-14     \n#>  7 Floren… actor         82 TRUE       1934-02-14      2016-11-24     \n#>  8 Harper… author        89 FALSE      1926-04-28      2016-02-19     \n#>  9 Zsa Zs… actor         99 TRUE       1917-02-06      2016-12-18     \n#> 10 George… musician      53 FALSE      1963-06-25      2016-12-25\n\nKey features:\nCan specify the intended column type (col_date()) and details needed to parse character data into the intended type (format = \"%m/%d/%Y\").\nCan address columns by name or position, falling back to a default.\nMore concise specifications are available for simpler situations.\nA specification is a first-class object: an instance of col_spec, which comes offers a few convenience functions.\n\n\ndeaths_spec <- spec(deaths_csv)\ndeaths_spec\n\n\n#> cols(\n#>   Name = col_character(),\n#>   Profession = col_character(),\n#>   Age = col_integer(),\n#>   `Has kids` = col_logical(),\n#>   `Date of birth` = col_date(format = \"%m/%d/%Y\"),\n#>   `Date of death` = col_date(format = \"%m/%d/%Y\")\n#> )\n\n\ncols_condense(deaths_spec)\n\n\n#> cols(\n#>   .default = col_character(),\n#>   Age = col_integer(),\n#>   `Has kids` = col_logical(),\n#>   `Date of birth` = col_date(format = \"%m/%d/%Y\"),\n#>   `Date of death` = col_date(format = \"%m/%d/%Y\")\n#> )\n\nIf you can accept the consequences, column type can be conveyed with single-character shortcodes. With deaths, we must either skip the dates or accept them as character.\n\n\nread_csv(\n  \"deaths.csv\",\n  skip = 4, n_max = 10,\n  col_types = \"??i?__\"\n)\n\n\n#> # A tibble: 10 x 4\n#>    Name               Profession   Age `Has kids`\n#>    <chr>              <chr>      <int> <lgl>     \n#>  1 David Bowie        musician      69 TRUE      \n#>  2 Carrie Fisher      actor         60 TRUE      \n#>  3 Chuck Berry        musician      90 TRUE      \n#>  4 Bill Paxton        actor         61 TRUE      \n#>  5 Prince             musician      57 TRUE      \n#>  6 Alan Rickman       actor         69 FALSE     \n#>  7 Florence Henderson actor         82 TRUE      \n#>  8 Harper Lee         author        89 FALSE     \n#>  9 Zsa Zsa Gábor      actor         99 TRUE      \n#> 10 George Michael     musician      53 FALSE\n\n\nread_csv(\n  \"deaths.csv\",\n  skip = 4, n_max = 10,\n  col_types = cols(Age = \"i\")\n)\n\n\n#> # A tibble: 10 x 6\n#>    Name    Profession   Age `Has kids` `Date of birth` `Date of death`\n#>    <chr>   <chr>      <int> <lgl>      <chr>           <chr>          \n#>  1 David … musician      69 TRUE       1/8/1947        1/10/2016      \n#>  2 Carrie… actor         60 TRUE       10/21/1956      12/27/2016     \n#>  3 Chuck … musician      90 TRUE       10/18/1926      3/18/2017      \n#>  4 Bill P… actor         61 TRUE       5/17/1955       2/25/2017      \n#>  5 Prince  musician      57 TRUE       6/7/1958        4/21/2016      \n#>  6 Alan R… actor         69 FALSE      2/21/1946       1/14/2016      \n#>  7 Floren… actor         82 TRUE       2/14/1934       11/24/2016     \n#>  8 Harper… author        89 FALSE      4/28/1926       2/19/2016      \n#>  9 Zsa Zs… actor         99 TRUE       2/6/1917        12/18/2016     \n#> 10 George… musician      53 FALSE      6/25/1963       12/25/2016\n\nI’m not getting into other parsing details, such as quote, locale, na, trim_ws, guess_max.\nreadxl\nThe col_types argument of readxl hasn’t changed ?much? since its original release. It’s considerably less flexible than readr. This is probably the top user-facing deficiency at this point.\n\n\n\ndeaths_xl <- read_excel(\n  readxl_example(\"deaths.xls\"),\n  range = \"arts!A5:F15\",\n  # skip = 4, n_max = 10,\n  col_types = c(\"text\", \"guess\", \"numeric\", \"logical\", \"date\", \"date\")\n  \n)\ndeaths_xl\n\n\n#> # A tibble: 10 x 6\n#>    Name               Profession   Age `Has kids` `Date of birth`    \n#>    <chr>              <chr>      <dbl> <lgl>      <dttm>             \n#>  1 David Bowie        musician      69 TRUE       1947-01-08 00:00:00\n#>  2 Carrie Fisher      actor         60 TRUE       1956-10-21 00:00:00\n#>  3 Chuck Berry        musician      90 TRUE       1926-10-18 00:00:00\n#>  4 Bill Paxton        actor         61 TRUE       1955-05-17 00:00:00\n#>  5 Prince             musician      57 TRUE       1958-06-07 00:00:00\n#>  6 Alan Rickman       actor         69 FALSE      1946-02-21 00:00:00\n#>  7 Florence Henderson actor         82 TRUE       1934-02-14 00:00:00\n#>  8 Harper Lee         author        89 FALSE      1926-04-28 00:00:00\n#>  9 Zsa Zsa Gábor      actor         99 TRUE       1917-02-06 00:00:00\n#> 10 George Michael     musician      53 FALSE      1963-06-25 00:00:00\n#> # … with 1 more variable: Date of death <dttm>\n\n\nwaldo::compare(deaths_xl, deaths_csv)\n\n\n#> Error in loadNamespace(x): there is no package called 'waldo'\n\nAlso notice: can’t specify integer or date, only numeric and date(time).\nThe one thing readxl has that’s arguably missing in readr is the list column type. Results in a list of length 1 vectors, with type-guessing at the individual cell level.\nTo demo this, we’ll use the clippy example spreadsheet.\n\n\nclippy <- read_excel(\n  readxl_example(\"clippy.xlsx\"),\n  col_types = c(\"text\", \"list\")\n)\nclippy\n\n\n#> # A tibble: 4 x 2\n#>   name                 value     \n#>   <chr>                <list>    \n#> 1 Name                 <chr [1]> \n#> 2 Species              <chr [1]> \n#> 3 Approx date of death <dttm [1]>\n#> 4 Weight in grams      <dbl [1]>\n\n\nclippy$value\n\n\n#> [[1]]\n#> [1] \"Clippy\"\n#> \n#> [[2]]\n#> [1] \"paperclip\"\n#> \n#> [[3]]\n#> [1] \"2007-01-01 UTC\"\n#> \n#> [[4]]\n#> [1] 0.9\n\n\nmap(clippy$value, class)\n\n\n#> [[1]]\n#> [1] \"character\"\n#> \n#> [[2]]\n#> [1] \"character\"\n#> \n#> [[3]]\n#> [1] \"POSIXct\" \"POSIXt\" \n#> \n#> [[4]]\n#> [1] \"numeric\"\n\ngooglesheets4\nThe col_types argument of googlesheets4 presents a specific subset of readr’s DSL: a string of single-character shortcodes. That’s it, that’s all that’s supported. The idea was to avoid creating yet another col_types system. But this leaves googlesheets4’s col_types argument as considerably less powerful than readr’s.\n\n\ngs4_example(\"deaths\") %>% \n  read_sheet(range = \"arts_data\", col_types = \"??i??D\")\n\n\n#> Reading from \"deaths\"\n#> Range \"arts_data\"\n#> # A tibble: 10 x 6\n#>    Name               Profession   Age `Has kids` `Date of birth`    \n#>    <chr>              <chr>      <int> <lgl>      <dttm>             \n#>  1 David Bowie        musician      69 TRUE       1947-01-08 00:00:00\n#>  2 Carrie Fisher      actor         60 TRUE       1956-10-21 00:00:00\n#>  3 Chuck Berry        musician      90 TRUE       1926-10-18 00:00:00\n#>  4 Bill Paxton        actor         61 TRUE       1955-05-17 00:00:00\n#>  5 Prince             musician      57 TRUE       1958-06-07 00:00:00\n#>  6 Alan Rickman       actor         69 FALSE      1946-02-21 00:00:00\n#>  7 Florence Henderson actor         82 TRUE       1934-02-14 00:00:00\n#>  8 Harper Lee         author        89 FALSE      1926-04-28 00:00:00\n#>  9 Zsa Zsa Gábor      actor         99 TRUE       1917-02-06 00:00:00\n#> 10 George Michael     musician      53 FALSE      1963-06-25 00:00:00\n#> # … with 1 more variable: Date of death <date>\n\nCompared to readxl:\nSupports explicit request for integer (see Age)\nSuccessfully guesses datetime for Date of birth\nSupports explicit request for Date (see Date of death)\nFor performance, we offer range_speedread(), which bypasses the Sheets API and reads csv, with readr, through a special URL.\n\n\ngs4_example(\"deaths\") %>% \n  range_speedread(\n    range = \"other!A5:F15\",\n    col_types = readr::cols(\n      Age = readr::col_integer(),\n      `Date of birth` = readr::col_date(\"%m/%d/%Y\"),\n      `Date of death` = readr::col_date(\"%m/%d/%Y\")\n    )\n  )\n\n\n#> Reading from \"deaths\", \"other\" sheet, range \"A5:F15\"\n#> Export URL: https://docs.google.com/spreadsheets/d/1VTJjWoP1nshbyxmL9JqXgdVsimaYty21LGxxs018H2Y/export?format=csv&range=A5%3AF15&gid=278837031\n#> # A tibble: 10 x 6\n#>    Name    Profession   Age `Has kids` `Date of birth` `Date of death`\n#>    <chr>   <chr>      <int> <lgl>      <date>          <date>         \n#>  1 Vera R… scientist     88 TRUE       1928-07-23      2016-12-25     \n#>  2 Mohame… athlete       74 TRUE       1942-01-17      2016-06-03     \n#>  3 Morley… journalist    84 TRUE       1931-11-08      2016-05-19     \n#>  4 Fidel … politician    90 TRUE       1926-08-13      2016-11-25     \n#>  5 Antoni… lawyer        79 TRUE       1936-03-11      2016-02-13     \n#>  6 Jo Cox  politician    41 TRUE       1974-06-22      2016-06-16     \n#>  7 Janet … lawyer        78 FALSE      1938-07-21      2016-11-07     \n#>  8 Gwen I… journalist    61 FALSE      1955-09-29      2016-11-14     \n#>  9 John G… astronaut     95 TRUE       1921-07-28      2016-12-08     \n#> 10 Pat Su… coach         64 TRUE       1952-06-14      2016-06-28\n\nThis really drives home that all of our col_types arguments are connected to each other, at the very least in our user’s mind, and often in more profound ways.\ngooglesheets4 also has a few innovations. Like readxl, googlesheets4 supports the \"list\" column type, where each cell gets its most suitable type.\nUnique to googlesheets4 is the \"cell\" column type, which reveals all the gory details about cell, in the spreadsheet sense. Consider the formulas-and-formats spreadsheet example Sheet.\n\n\n\n\nLet’s use a more primitive function to inspect the hyperlink cell E2.\n\n\nx <- gs4_example(\"formulas-and-formats\") %>% \n  range_read_cells(range = \"E2:E2\", cell_data = \"full\")\n\n\n#> Reading from \"formulas-and-formats\"\n#> Range \"E2:E2\"\n\nx\n\n\n#> # A tibble: 1 x 4\n#>     row   col loc   cell      \n#>   <int> <int> <chr> <list>    \n#> 1     2     5 E2    <CELL_TEX>\n\n\nstr(x$cell[[1]])\n\n\n#> List of 6\n#>  $ userEnteredValue :List of 1\n#>   ..$ formulaValue: chr \"=HYPERLINK(\\\"http://www.google.com/\\\",\\\"Google\\\")\"\n#>  $ effectiveValue   :List of 1\n#>   ..$ stringValue: chr \"Google\"\n#>  $ formattedValue   : chr \"Google\"\n#>  $ userEnteredFormat:List of 1\n#>   ..$ textFormat:List of 1\n#>   .. ..$ link:List of 1\n#>   .. .. ..$ uri: chr \"http://www.google.com/\"\n#>  $ effectiveFormat  :List of 8\n#>   ..$ backgroundColor     :List of 3\n#>   .. ..$ red  : int 1\n#>   .. ..$ green: int 1\n#>   .. ..$ blue : int 1\n#>   ..$ padding             :List of 2\n#>   .. ..$ right: int 3\n#>   .. ..$ left : int 3\n#>   ..$ horizontalAlignment : chr \"LEFT\"\n#>   ..$ verticalAlignment   : chr \"BOTTOM\"\n#>   ..$ wrapStrategy        : chr \"OVERFLOW_CELL\"\n#>   ..$ textFormat          :List of 9\n#>   .. ..$ foregroundColor     :List of 1\n#>   .. .. ..$ blue: int 1\n#>   .. ..$ fontFamily          : chr \"Calibri\"\n#>   .. ..$ fontSize            : int 10\n#>   .. ..$ bold                : logi FALSE\n#>   .. ..$ italic              : logi FALSE\n#>   .. ..$ strikethrough       : logi FALSE\n#>   .. ..$ underline           : logi TRUE\n#>   .. ..$ foregroundColorStyle:List of 1\n#>   .. .. ..$ rgbColor:List of 1\n#>   .. .. .. ..$ blue: int 1\n#>   .. ..$ link                :List of 1\n#>   .. .. ..$ uri: chr \"http://www.google.com/\"\n#>   ..$ hyperlinkDisplayType: chr \"LINKED\"\n#>   ..$ backgroundColorStyle:List of 1\n#>   .. ..$ rgbColor:List of 3\n#>   .. .. ..$ red  : int 1\n#>   .. .. ..$ green: int 1\n#>   .. .. ..$ blue : int 1\n#>  $ hyperlink        : chr \"http://www.google.com/\"\n#>  - attr(*, \"class\")= chr [1:2] \"CELL_TEXT\" \"SHEETS_CELL\"\n\nI show to make two points:\nIt’s nice that googlesheets4 can expose this for the user that needs it. We have to have this internally anyway. I wish readxl did similar.\nCreating R “atoms” and columns from spreadsheet data is very different than doing the same for, say, csv. We have a lot more info!\ntidyr (and vctrs)\nThe new-ish rectangling features in tidyr essentially expose another DSL for how to specify the type of new columns, influenced by the vctrs package and its notion of prototype.\nNote this is a related, but distinct problem space, because we are no longer parsing external data into new R columns. This is a fully “within R” operation.\npivot_wider()\nI realized once I started this that pivot_wider() currently does not support what I wanted to show! It does have a concept of a pivot spec, but currently it does not have anything to do with column type. pivot_wider() certainly could produce columns of disparate type, if it was instructed to implement a spec.\nI read deaths in again, but universally as character, then use pivot_longer() on it.\n\n\ndeaths_character <- read_csv(\n  \"deaths.csv\",\n  skip = 4, n_max = 10,\n  col_types = cols(.default = col_character())\n)\n\ndeaths_character_long <- deaths_character %>% \n  rowid_to_column() %>% \n  pivot_longer(-rowid)\ndeaths_character_long\n\n\n#> # A tibble: 60 x 3\n#>    rowid name          value        \n#>    <int> <chr>         <chr>        \n#>  1     1 Name          David Bowie  \n#>  2     1 Profession    musician     \n#>  3     1 Age           69           \n#>  4     1 Has kids      TRUE         \n#>  5     1 Date of birth 1/8/1947     \n#>  6     1 Date of death 1/10/2016    \n#>  7     2 Name          Carrie Fisher\n#>  8     2 Profession    actor        \n#>  9     2 Age           60           \n#> 10     2 Has kids      TRUE         \n#> # … with 50 more rows\n\n\n# another way to get an ID column, seen in rectangling vignette\n# deaths_character %>% \n#   mutate(rowid = cumsum(name == \"Name\"))\n\n\n\nNow we accomplish what a proper import would do, but with tidyr’s toolkit. Nope, no we don’t, because pivot_wider() doesn’t support this. At this point, we’d use readr’s parsers on the columns.\n\n\ndeaths_character_long %>% \n  pivot_wider(\n    id_cols = rowid,\n    )\n\n\n#> # A tibble: 10 x 7\n#>    rowid Name              Profession Age   `Has kids` `Date of birth`\n#>    <int> <chr>             <chr>      <chr> <chr>      <chr>          \n#>  1     1 David Bowie       musician   69    TRUE       1/8/1947       \n#>  2     2 Carrie Fisher     actor      60    TRUE       10/21/1956     \n#>  3     3 Chuck Berry       musician   90    TRUE       10/18/1926     \n#>  4     4 Bill Paxton       actor      61    TRUE       5/17/1955      \n#>  5     5 Prince            musician   57    TRUE       6/7/1958       \n#>  6     6 Alan Rickman      actor      69    FALSE      2/21/1946      \n#>  7     7 Florence Henders… actor      82    TRUE       2/14/1934      \n#>  8     8 Harper Lee        author     89    FALSE      4/28/1926      \n#>  9     9 Zsa Zsa Gábor     actor      99    TRUE       2/6/1917       \n#> 10    10 George Michael    musician   53    FALSE      6/25/1963      \n#> # … with 1 more variable: Date of death <chr>\n\nunnest_wider()\nFirst, prepare the deaths data: read in as character and then transpose. We get a list, with one component per row = person.\n\n\ndeaths_character <- read_csv(\n  \"deaths.csv\",\n  skip = 4, n_max = 10,\n  col_types = cols(.default = col_character())\n)\n\ndeaths_character_transpose <- deaths_character %>% \n  transpose()\nhead(deaths_character_transpose, 2)\n\n\n#> [[1]]\n#> [[1]]$Name\n#> [1] \"David Bowie\"\n#> \n#> [[1]]$Profession\n#> [1] \"musician\"\n#> \n#> [[1]]$Age\n#> [1] \"69\"\n#> \n#> [[1]]$`Has kids`\n#> [1] \"TRUE\"\n#> \n#> [[1]]$`Date of birth`\n#> [1] \"1/8/1947\"\n#> \n#> [[1]]$`Date of death`\n#> [1] \"1/10/2016\"\n#> \n#> \n#> [[2]]\n#> [[2]]$Name\n#> [1] \"Carrie Fisher\"\n#> \n#> [[2]]$Profession\n#> [1] \"actor\"\n#> \n#> [[2]]$Age\n#> [1] \"60\"\n#> \n#> [[2]]$`Has kids`\n#> [1] \"TRUE\"\n#> \n#> [[2]]$`Date of birth`\n#> [1] \"10/21/1956\"\n#> \n#> [[2]]$`Date of death`\n#> [1] \"12/27/2016\"\n\nRe-create deaths_csv via unnest_wider(). First, without worrying about column types.\n\n\ndat <- tibble(stuff = deaths_character_transpose)\n\ndat %>% \n  unnest_wider(stuff)\n\n\n#> # A tibble: 10 x 6\n#>    Name    Profession Age   `Has kids` `Date of birth` `Date of death`\n#>    <chr>   <chr>      <chr> <chr>      <chr>           <chr>          \n#>  1 David … musician   69    TRUE       1/8/1947        1/10/2016      \n#>  2 Carrie… actor      60    TRUE       10/21/1956      12/27/2016     \n#>  3 Chuck … musician   90    TRUE       10/18/1926      3/18/2017      \n#>  4 Bill P… actor      61    TRUE       5/17/1955       2/25/2017      \n#>  5 Prince  musician   57    TRUE       6/7/1958        4/21/2016      \n#>  6 Alan R… actor      69    FALSE      2/21/1946       1/14/2016      \n#>  7 Floren… actor      82    TRUE       2/14/1934       11/24/2016     \n#>  8 Harper… author     89    FALSE      4/28/1926       2/19/2016      \n#>  9 Zsa Zs… actor      99    TRUE       2/6/1917        12/18/2016     \n#> 10 George… musician   53    FALSE      6/25/1963       12/25/2016\n\nNow we’ll use .transform to get correct column types.\n\n\ndeaths_wider <- dat %>% \n  unnest_wider(\n    stuff,\n    transform = list(\n      Age = as.integer,\n      `Has kids` = as.logical,\n      `Date of birth` = ~ as.Date(.x, format = \"%m/%d/%Y\"),\n      `Date of death` = ~ as.Date(.x, format = \"%m/%d/%Y\")\n      )\n  )\ndeaths_wider\n\n\n#> # A tibble: 10 x 6\n#>    Name    Profession   Age `Has kids` `Date of birth` `Date of death`\n#>    <chr>   <chr>      <int> <lgl>      <date>          <date>         \n#>  1 David … musician      69 TRUE       1947-01-08      2016-01-10     \n#>  2 Carrie… actor         60 TRUE       1956-10-21      2016-12-27     \n#>  3 Chuck … musician      90 TRUE       1926-10-18      2017-03-18     \n#>  4 Bill P… actor         61 TRUE       1955-05-17      2017-02-25     \n#>  5 Prince  musician      57 TRUE       1958-06-07      2016-04-21     \n#>  6 Alan R… actor         69 FALSE      1946-02-21      2016-01-14     \n#>  7 Floren… actor         82 TRUE       1934-02-14      2016-11-24     \n#>  8 Harper… author        89 FALSE      1926-04-28      2016-02-19     \n#>  9 Zsa Zs… actor         99 TRUE       1917-02-06      2016-12-18     \n#> 10 George… musician      53 FALSE      1963-06-25      2016-12-25\n\n\nwaldo::compare(deaths_csv, deaths_wider)\n\n\n#> Error in loadNamespace(x): there is no package called 'waldo'\n\nThere’s also a ptype argument that is currently used just for checking. But I wonder, if for simple as.WHATEVER transformations, if it could do double duty?\nFor discussion\nWe have a long-running Google doc about this, that predates the existence of vctrs\nEmulating readr’s DSL fully feels like the (a?) right answer for readxl and googlesheets4. But currently a readr col spec is very much expressed in terms of readr-only objects, e.g. collectors.\nDo we have an appetite for extracting col spec into something more abstract? tidyr’s “wider/hoist spec” starts to hint at this.\nFrom old google doc:\nCol spec as a tibble, one row per column, maybe one row for defaults?\nAddress columns by name or position/index/location\nparse_as, parse_params\nCol spec can be constructed de novo or discovered from an object\nShared infrastructure re: problems, i.e. what happens when a spec meets real world data?\nWhat about transmitting more re: the input to the resulting column? I’m talking about dates, datetimes, (in the future) percentage, currency, rounding / scientific notation.\n\n\n\n",
      "last_modified": "2021-06-07T17:33:51+00:00"
    }
  ],
  "collections": []
}
